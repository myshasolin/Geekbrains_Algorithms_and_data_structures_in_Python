# Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать
# на вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
# Второй — без использования «Решета Эратосфена».

# Пример работы программ:
# >>> sieve(2)
# 3
# >>> prime(4)
# 7
# >>> sieve(5)
# 11
# >>> prime(1)
# 2

# мы внутри цикла while крутимся до тех пор, пока итоговый список не будет по длине равен нашему i-му числу. В итоговый
# список мы прибавляем элемент "цифра+1", при этом проверяем - если "цифра+1" делится на элементы списка без остатка,
# то её не добавляем. В результат выводим послений элемент сформированного списка - он и будет нужным нам числом.
# Скорость такого варианта поиска числа, по сравнению с Решетом Эратосфена, гораздо ниже. В ожидании последних замеров
# в 1000 попыток я успел просмотреть 2 серии Игры Престолов, а лучшее время получилось длиной аж 4.69 секунд - всё из-за
# постоянно повторяющегося цикла for с перебором постоянно увеличивающегося списка в постоянно крутящемся while

# этот вариант решения в два раза легче решета Эрастофена
from sum_size import sum_size, operating_system_version


operating_system_version()
# win32 3.9.6 (tags/v3.9.6:db3ff76, Jun 28 2021, 15:26:21) [MSC v.1929 64 bit (AMD64)]


def my_func(num):
    result_list, elem_list = [2], 3
    while len(result_list) < num:
        step = True
        for i in result_list.copy():
            if elem_list % i == 0:
                step = False
                break
        if step:
            result_list.append(elem_list)
        elem_list += 1
    print(f'{num} это число {result_list[-1]}')
    sum_size(num, result_list, elem_list, step, i, result_list.copy())


# answer_num = my_func(int(input('Пиши число вот сюда: ')))
answer_num = 50
my_func(answer_num)

# использовано переменных: 6
# общий их вес: 1040
